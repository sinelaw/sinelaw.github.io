<p>In the past month, most of the work on <a href="https://github.com/sinelaw/infernu">infernu</a> was to stabilize the type system, making decisions about some trade-offs. Here’s a short summary:</p>

<ul>
  <li><strong>Colors!</strong> I refactored all the pretty printing code to use the ansi-wl-pprint package, which fixes indentation and formatting issues and also adds ansi colors to the output. One neat thing is that identical type variables have the same color: <a href="https://noamlewis.wordpress.com/wp-content/uploads/2015/06/infernu-colors.png"><img src="images/infernu-colors.png" alt="infernu-colors" /></a></li>
  <li>Changed the way constructor functions are treated. Until now, constructor functions were treated at definition site as regular functions. The difference between constructors and non-constructors only happened at “new” calls, where the expected “this” value was forced to be a closed row type. Unfortunately this breaks if you call “new Foo()” inside the definition of “Foo”. To avoid this issue, functions with uppercase names are now treated specially and the “this” row-type is forced to be closed when the function name is added to the environment. This allows maximum flexibility while defining Foo, while ensuring Foo’s type is closed outside the constructor to prevent junk code like <code class="language-plaintext highlighter-rouge">var x = new Foo(); x.myWrongProperty = 2;</code></li>
  <li>Explored the idea of “Maybe” (or “optional”) types, including having common JS APIs use them for stronger safety. For example, array access should return a Maybe value. Unfortunately, since there is no syntax to construct a Maybe-typed value (no “Just”), all values can be implicitly “upgradeed” to Maybe. In other words, there is an ambiguity that break type inference. So for now, not implementing Maybe types (perhaps with explicit annotations they can come back).</li>
  <li>Decided to disable generalization of row fields (object properties). This decision means that user-defined objects will by default <strong>not have polymorphic methods</strong>, although the object itself could be polymorphic (and thus different occurrences of the object in the program syntax, will allow instantiation to different types). The reason for this decision is that overly-polymorphic fields cause unexpected type errors, such as when passing objects that contain them as parameters to functions (contravariance can surprise you).</li>
  <li>Started a document sketching out denotational semantics of JS, <strong>as infernu decides these should be</strong>, which helped clarify a few issues in the JS -&gt; LC translator. The next step is to change all translations to preserve semantics, currently they only preserve types.</li>
  <li>Bug fixes: polymorphic subsumption checking, unification of recursive types.</li>
  <li>Increased compatibility: now using base-compat and a custom prelude to increase compatibility with different GHC versions (thanks to RyanGlScott for submitting a fix to use base-orphans which prompted me to do this).</li>
</ul>
